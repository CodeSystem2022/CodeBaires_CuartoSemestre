// Generated by CoffeeScript 1.6.3
var express,
  __slice = [].slice;

express = require('express');

module.exports = function(app, fn) {
  var env, verb, wrapper, _fn, _fn1, _i, _j, _len, _len1, _ref, _ref1, _ref2;
  if (app == null) {
    app = express();
  }
  if (typeof (app != null ? app.listen : void 0) !== 'function') {
    _ref = [app, express()], fn = _ref[0], app = _ref[1];
  }
  wrapper = function(fn) {
    return fn.call(wrapper);
  };
  wrapper.app = app;
  wrapper.locals = app.locals;
  wrapper.routes = app.routes;
  wrapper.configure = function() {
    return app.configure.apply(app, arguments);
  };
  _ref1 = ['development', 'production', 'test'];
  _fn = function(env) {
    return wrapper[env] = function(fn) {
      return app.configure.call(app, env, function() {
        return fn.call(app);
      });
    };
  };
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    env = _ref1[_i];
    _fn(env);
  }
  _ref2 = ['all', 'get', 'patch', 'post', 'put', 'del'];
  _fn1 = function(verb) {
    return wrapper[verb] = function() {
      var args, handler, middleware, mw, path;
      path = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (verb === 'get' && args.length === 0) {
        return app.get(path);
      }
      handler = args.pop();
      middleware = [];
      while (mw = args.pop()) {
        if (Array.isArray(mw)) {
          middleware = middleware.concat(mw);
        } else {
          middleware.push(mw);
        }
      }
      return app[verb](path, middleware, function(req, res, next) {
        var ctx;
        ctx = {
          next: next,
          req: req,
          res: res,
          accepted: req.accepted,
          acceptedCharsets: req.acceptedCharsets,
          acceptedLanguages: req.acceptedLanguages,
          body: req.body,
          cookies: req.cookies,
          files: req.files,
          fresh: req.fresh,
          host: req.host,
          ip: req.ip,
          ips: req.ips,
          originalUrl: req.originalUrl,
          params: req.params,
          path: req.path,
          protocol: req.protocol,
          query: req.query,
          route: req.route,
          secure: req.secure,
          signedCookies: req.signedCookies,
          stale: req.stale,
          subdomains: req.subdomains,
          xhr: req.xhr,
          accepts: function() {
            return req.accepts.apply(req, arguments);
          },
          acceptsCharset: function() {
            return req.acceptCharset.apply(req, arguments);
          },
          acceptsLanguage: function() {
            return req.acceptsLanguage.apply(req, arguments);
          },
          is: function() {
            return req.is.apply(req, arguments);
          },
          param: function() {
            return req.param.apply(req, arguments);
          },
          charset: res.charset,
          locals: res.locals,
          attachment: function() {
            return res.attachment.apply(res, arguments);
          },
          clearCookie: function() {
            return res.clearCookie.apply(res, arguments);
          },
          cookie: function() {
            return res.cookie.apply(res, arguments);
          },
          download: function() {
            return res.download.apply(res, arguments);
          },
          format: function() {
            return res.format.apply(res, arguments);
          },
          json: function() {
            return res.json.apply(res, arguments);
          },
          jsonp: function() {
            return res.jsonp.apply(res, arguments);
          },
          links: function() {
            return res.links.apply(res, arguments);
          },
          location: function() {
            return res.location.apply(res, arguments);
          },
          redirect: function() {
            return res.redirect.apply(res, arguments);
          },
          render: function() {
            return res.render.apply(res, arguments);
          },
          send: function() {
            return res.send.apply(res, arguments);
          },
          sendfile: function() {
            return res.sendfile.apply(res, arguments);
          },
          status: function() {
            return res.status.apply(res, arguments);
          },
          type: function() {
            return res.type.apply(res, arguments);
          }
        };
        return handler.apply(ctx, req.params);
      });
    };
  };
  for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
    verb = _ref2[_j];
    _fn1(verb);
  }
  wrapper.extend = function() {
    var fns;
    if (!Array.isArray(fns)) {
      fns = [fns];
    }
    return fns.map(wrapper);
  };
  wrapper.set = function() {
    return app.set.apply(app, arguments);
  };
  wrapper.enable = function() {
    return app.enable.apply(app, arguments);
  };
  wrapper.disable = function() {
    return app.disable.apply(app, arguments);
  };
  wrapper.enabled = function() {
    return app.enabled.apply(app, arguments);
  };
  wrapper.disabled = function() {
    return app.disabled.apply(app, arguments);
  };
  wrapper.use = function() {
    return app.use.apply(app, arguments);
  };
  wrapper.engine = function() {
    return app.engine.apply(app, arguments);
  };
  wrapper.param = function() {
    return app.param.apply(app, arguments);
  };
  wrapper.all = function() {
    return app.all.apply(app, arguments);
  };
  wrapper.render = function() {
    return app.render.apply(app, arguments);
  };
  wrapper.listen = function() {
    return app.listen.apply(app, arguments);
  };
  wrapper.run = function() {
    var args, port, server;
    port = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (port == null) {
      port = 3000;
    }
    args.unshift(port);
    if (isNaN(port)) {
      args.unshift(3000);
    }
    server = app.listen.apply(app, args);
    return wrapper.stop = wrapper.close = function() {
      return server.close.apply(server, arguments);
    };
  };
  if (fn != null) {
    wrapper(fn);
  }
  return wrapper;
};

/*
//@ sourceMappingURL=ex.map
*/
